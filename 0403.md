# 04/03 进展报告

## 实现riscv平台下浮点状态保存和恢复

starry next是跨平台的实现，我们需要在4种架构上实现相同的功能。得益于底层axhal的抽象，在实现绝大部分功能时我们无需考虑底层CPU平台的差异。然而，我们发现，在实现很多平台无关功能时，在其他平台上都能工作的功能可能在某些平台上会报错，这个是因为axhal的实现还不够完善，在某些场景下存在问题。例如：

- 在riscv64平台上，由于没有启用浮点运算功能，同时没有实现浮点状态的保存和恢复，因此涉及浮点运算的代码执行时会出现`IllegalInstruction`异常。这个问题是我上周发现和报告的，我这周完成了相应的实现。
- 在x86_64平台上，由于没有实现任务相关的tls切换，导致在特定场景下，会出现异常。这个问题在GitHub issue上已经报告，并被其他人修复了。
- 在x86_64平台上，目前仍有部分测例仅在该平台上出现PageFault异常，而在其他平台上没有这个问题。目前我们正在调查这个问题的原因，并尝试修复它。

上周我最早在riscv64平台上运行`busybox sh`程序时，发现了`IllegalInstruction`异常。经过调试，发现是由于没有实现浮点状态的保存和恢复导致的。这个问题在上周已经报告，我查阅了riscv specification，了解了riscv浮点单元的4种状态，基于此，我独立实现了浮点状态的保存和恢复。在实现完成后，我向上游ArceOS提交了PR，在几经修改后，PR已经合并到上游仓库。这个工作加深了我对ArceOS任务管理和进程调度流程的理解，也加深了我对riscv架构的理解。同时，我也锻炼了rust代码的编写能力，了解了文档编写和代码规范相关的内容。

## 实现更多的系统调用

在实现了浮点状态的保存和恢复后，我继续实现了十余个新的系统调用，其中一部分实现为桩函数，一部分实现为具有初步功能的系统调用。在前几周的测试中，我们没有添加对libctest的测试，因此在本周加入这些测试后，发现我们的工作已经可以使得相当多的测例通过了。我们在此基础上编写了一些新的系统调用，通过了一些新的测例。遗憾的是，我们实现的部分系统调用在x86_64平台上仍然存在问题，可能与底层的`axhal`实现有关。我们正在调查这个问题，准备在下周修复它。

## 测例文档相关

参与编写了lmbench的测例文档，包括了评分标准和测试内容等。已经提交pr并合并到上游仓库。

## 下周任务

- 继续实现更多的系统调用，争取通过更多的libctest测例
- 调查上面提及的x86_64平台上存在的问题
- 尝试busybox测例
