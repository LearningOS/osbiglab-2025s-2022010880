# 04/17 进展报告

## 代码结构重构

如上次中期汇报中我提到的，我们正在对项目的代码结构进行重构。目前项目代码结构比较混乱，因为很多代码引用了`arceos_posix_api`库中的代码，导致一个系统调用需要层层嵌套调用一系列函数才能执行到最终的实现函数，返回值甚至也被反复包装-解包了数次。我们正在对这些代码进行重构，尽量减少不必要的函数调用和数据结构转换，以提高代码的可读性和可维护性，同时提高系统调用的效率。

目前我希望对项目的结构进行如下改进：

- 移除`arceos_posix_api`库，直接在`api`这个crate中实现所有的系统调用。以减少不必要的包装函数，提高可读性和执行效率。
- 将`api`这个crate中的代码分为两个部分：一个是实系统调用本身的**实现**部分，另一个是对应POSIX标准的**接口**部分。
- 实现一个通用的宏，用于自动生成类似`strace`输出的系统调用日志打印代码，便于调试和分析系统调用的执行过程。

下面将逐一介绍。

### 移除`arceos_posix_api`库

这个原因上面也已经提到过了，就是避免不必要的函数调用和数据结构转换。我们在实现系统调用时，直接在`api`这个crate中实现所有的系统调用，而不是在`arceos_posix_api`库中实现，然后再在`api`这个crate中调用。此外，另一个考量是部分`arceos_posix_api`中的系统调用实现的不够完善，有时候缺少部分功能或有缺陷，这个在中期报告中也有提及，我们也希望借这个机会仔细排查一下原有实现中的问题。这部分重构工作需要一定的工作量，我们准备渐进式地迁移。

### 将系统调用的编写分为“接口”和“实现”两部分

做这个修改的初衷是，我们发现许多系统调用有着相似的名字和类似的功能，往往存在部分系统调用的功能是重叠的，或者是包含在其他系统调用中的。这其中有一部分的历史原因，Linux在演进的过程中，不可避免地会因为旧系统调用的缺陷而引入新的改进版本的系统调用，从而导致了系统调用的重复和冗余。例如`stat`,`fstat`, `lstat`, `statx`, `fstatat`，以及`poll`, `ppoll`, `pselect`等系统调用。我们希望在实现系统调用时，能够将这些系统调用的实现进行整合，避免重复的代码和不必要的复杂性。因为如果为功能相近的若干系统调用分别实现一遍代码，可能在排查问题或者需要进行修复时，需要在多个地方进行修改，存在遗漏的风险。

此外，虽然我们的目标是提供Linux兼容的POSIX API，但如果未来我们希望支持其他OS的API，或者提供我们的自定义API，那么这种结构的划分也会让我们在实现时更加灵活。

具体地，我们整合一类功能相近或彼此包含的系统调用，实现一个通用的实现函数以完成它们的功能的并集，作为**实现**部分。然后为每个系统调用单独提供一个**接口**函数，作为对应用程序的接口，函数内进行参数的检查和转换，以合适的参数组合调用对应的实现函数。具体规范包含下面的部分：

- **实现**部分的函数名为`sys_XXX_impl`，其中`XXX`为系统调用的名称。实现部分的函数参数和返回值都是rust原生类型，不涉及指针读写和数据结构转换等工作，只关心系统调用功能实现。
- **接口**部分的函数名为`sys_XXX`，其中`XXX`为系统调用的名称。接口部分的函数参数和返回值为POSIX标准定义的类型，函数内进行参数的检查和转换，以合适的参数组合调用对应的实现函数。接口部分的函数需要处理指针读写和数据结构转换等工作，可能会涉及到unsafe代码。
- **接口**部分的函数参数主要有两类：一类是rust定义的c语言接口类型，如`c_int`等，另一类是指针类型。此处我们对用户指针类型进一步进行了语义化包装，命名为`UserInPtr<T>`, `UserOutPtr<T>`, `UserInOutPtr<T>`，分别表示输入指针、输出指针和输入输出指针。我们在实现时，使用这些语义化的指针类型来替代原有的指针类型，以提高代码的可读性和可维护性，同时便于添加合适的权限和边界检查。
- **接口**部分的函数可能需要处理数据结构转换等工作，在**实现**部分返回的结构体为内核的内部类型，可能和POSIX标准中规定的和用户交互的类型有所不同。甚至，在不同的架构下，Linux规定的数据结构也可能会有所不同，可能存在字段顺序不同、字段大小不同等问题。我们在实现时，使用`#[repr(C)]`属性来指定数据结构的内存布局，同时针对不同的架构，使用`cfg`宏来管理不同架构下的用户结构体。

### 实现一个通用的宏，用于自动生成类似`strace`输出的系统调用日志打印代码

目前我们的代码框架中，存在自动打印系统调用名称和返回值的代码。但这可能远远不够，因为我们还需要打印系统调用的参数和作为结构体返回给用户的信息。目前部分系统调用存在手动实现的打印代码，但这显然是低效的，且容易遗漏，在改变函数签名时，可能会遗漏打印代码的修改。同时，这些打印代码可能不能合适地打印（包装）指针指向的结构体的内容。

我们希望实现一个宏，能够自动生成类似`strace`输出的系统调用日志打印代码，便于调试和分析系统调用的执行过程。这个宏可以在编译时根据函数签名自动生成打印代码，避免手动实现的错误和遗漏。我目前选择的方案是使用rust的过程宏，如果为函数加上`#[syscall_trace]`属性，编译器会自动生成打印代码，在进入函数时打印函数名和参数（含非`UserOutPtr`指针指向的内容），然后在闭包中执行函数体，最后打印返回值。目前实现中还有一些问题，虽然可以工作，但实现的说实话没那么优雅，可能需要讨论一下。

输出可能类似：

```rust
[syscall] <= sys_fstatat(dir_fd = -100, path = "busybox" @ VA:0x3ffffffcb, stat_buf = ... @ VA:0x3fffffab0, flags = 0)
[syscall] => sys_fstatat(dir_fd = -100, path = "busybox" @ VA:0x3ffffffcb, stat_buf = UserStat { st_dev: 0, st_ino: 1, st_mode: 33188, st_nlink: 1, st_uid: 1000, st_gid: 1000, st_rdev: 0, _pad0: 0, st_size: 1104040, st_blksize: 512, _pad1: 0, st_blocks: 2157, st_atime: TimeSpec { seconds: 0, nanoseconds: 0 }, st_mtime: TimeSpec { seconds: 0, nanoseconds: 0 }, st_ctime: TimeSpec { seconds: 0, nanoseconds: 0 }, _unused: [0, 0] } @ VA:0x3fffffab0, flags = 0) = 0
```

## 进程与线程实现

我们知道，线程应该是调度单位，而目前我们OS的调度单位是`axtask`。为了添加线程的支持，我们可以将进程设计为类似线程组的东西，作为线程的集合。在创建新的任务时，我们认为创建了一个包含一个线程的新进程，我们将线程信息保存在`TaskExt`中，然后使用引用计数来持有新创建的进程，从而实现不同的线程共享进程信息，并且在所有线程销毁时销毁进程信息。

上次另一组同学提及了关于`AxNamespace`内存泄漏相关的问题，目前我倾向于直接在`TaskExt`中持有线程特有的结构，未来可能不再使用`AxNamespace`。

目前实现的复杂性可能主要来源于`AxTask`可能调度的对象可能是用户线程，也可能是内核线程。之前另一组同学用了`Box`来持有相关对象，按照郑学长的意思是可能还有改进空间，他们借鉴了星绽OS的实现，我们目前不打算直接使用他们的实现，我们计划认真调研现有OS，如Linux，Windows，包括星绽和ByteOS等的实现，然后从头实现一个更为合理的设计。

## 未来展望

目前我们不急于刷分，我们希望能认真投入时间来实现一个实现完善的OS，不仅仅是为了通过测例，而是为了能设计一个完善的框架，以便在未来能够更好地扩展和维护，这也是一个沉淀的过程，因此本周的工作侧重于代码结构的优化和一些辅助工具的实现，以及一些进程/线程实现方向上的调研。而且，本周我们还有几门期中考试需要参加，因此时间上也比较紧张。我们希望下周能够继续推进项目结构优化相关的工作，优化重写现有系统调用，然后开始实现进程/线程相关的内容。
